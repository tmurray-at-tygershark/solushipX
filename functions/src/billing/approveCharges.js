const { onCall } = require('firebase-functions/v2/https');
const admin = require('firebase-admin');
const logger = require('firebase-functions/logger');

const db = admin.firestore();

/**
 * Approve charges for shipments with audit trail and status management
 */
const approveCharges = onCall({
    cors: true,
    maxInstances: 10,
    timeoutSeconds: 60
}, async (request) => {
    try {
        const { 
            shipmentIds, 
            approvalType = 'individual', // 'individual' or 'bulk'
            overrideExceptions = false,
            approvalNotes = ''
        } = request.data;
        
        const userId = request.auth?.uid;
        const userEmail = request.auth?.email;

        if (!userId) {
            throw new Error('Authentication required');
        }

        if (!shipmentIds || !Array.isArray(shipmentIds) || shipmentIds.length === 0) {
            throw new Error('Shipment IDs array is required');
        }

        logger.info('✅ Approving charges', {
            shipmentCount: shipmentIds.length,
            approvalType,
            overrideExceptions,
            userId
        });

        const results = [];
        const errors = [];

        // Process each shipment
        for (const shipmentId of shipmentIds) {
            try {
                const result = await processShipmentApproval(
                    shipmentId, 
                    userId, 
                    userEmail, 
                    overrideExceptions,
                    approvalNotes
                );
                results.push(result);
            } catch (error) {
                logger.error(`❌ Failed to approve shipment ${shipmentId}:`, error);
                errors.push({
                    shipmentId,
                    error: error.message
                });
            }
        }

        const successCount = results.filter(r => r.success).length;
        const failureCount = errors.length;

        return {
            success: failureCount === 0,
            processedCount: shipmentIds.length,
            successCount: successCount,
            failureCount: failureCount,
            results: results,
            errors: errors,
            message: `Processed ${successCount}/${shipmentIds.length} shipments successfully`
        };

    } catch (error) {
        logger.error('❌ Bulk approval error:', error);
        return {
            success: false,
            error: error.message
        };
    }
});

/**
 * Process approval for a single shipment
 */
async function processShipmentApproval(shipmentId, userId, userEmail, overrideExceptions, approvalNotes) {
    // Get shipment document
    const shipmentDoc = await db.collection('shipments').doc(shipmentId).get();
    if (!shipmentDoc.exists) {
        throw new Error(`Shipment ${shipmentId} not found`);
    }

    const shipmentData = shipmentDoc.data();
    const currentStatus = shipmentData.chargeStatus?.status || 'pending_review';

    // Check if shipment can be approved
    const canApprove = await validateApproval(shipmentData, overrideExceptions);
    if (!canApprove.allowed) {
        throw new Error(canApprove.reason);
    }

    // Prepare approval update
    const approvalData = {
        chargeStatus: {
            status: 'approved',
            approvedBy: userEmail,
            approvedAt: admin.firestore.FieldValue.serverTimestamp(),
            approvedByUserId: userId,
            previousStatus: currentStatus,
            overrideExceptions: overrideExceptions,
            approvalNotes: approvalNotes || '',
            autoGenerated: false
        },
        
        // Update invoice status if not set
        invoiceStatus: shipmentData.invoiceStatus || 'uninvoiced',
        
        // Track approval in status history
        [`statusHistory.${Date.now()}`]: {
            status: shipmentData.status || 'unknown',
            timestamp: admin.firestore.FieldValue.serverTimestamp(),
            note: overrideExceptions ? 
                `Charges approved with exception override: ${approvalNotes}` :
                `Charges approved: ${approvalNotes}`,
            updatedBy: userEmail,
            type: 'charges_approved',
            changes: {
                previousChargeStatus: currentStatus,
                newChargeStatus: 'approved',
                overrideExceptions: overrideExceptions,
                exceptionCount: shipmentData.exceptionStatus?.exceptionCount || 0
            }
        }
    };

    // If overriding exceptions, mark them as resolved
    if (overrideExceptions && shipmentData.exceptionStatus?.hasExceptions) {
        approvalData.exceptionStatus = {
            ...shipmentData.exceptionStatus,
            resolvedAt: admin.firestore.FieldValue.serverTimestamp(),
            resolvedBy: userEmail,
            resolutionMethod: 'admin_override',
            resolutionNotes: approvalNotes
        };
    }

    // Update shipment document
    await db.collection('shipments').doc(shipmentId).update(approvalData);

    // Log approval event
    await logApprovalEvent(shipmentId, shipmentData.shipmentID, userEmail, overrideExceptions, approvalNotes);

    return {
        success: true,
        shipmentId: shipmentId,
        shipmentID: shipmentData.shipmentID,
        previousStatus: currentStatus,
        newStatus: 'approved',
        overrideExceptions: overrideExceptions,
        message: 'Charges approved successfully'
    };
}

/**
 * Validate if shipment can be approved
 */
async function validateApproval(shipmentData, overrideExceptions) {
    // Check if shipment is cancelled
    if (shipmentData.status === 'cancelled' || shipmentData.status === 'canceled') {
        return {
            allowed: false,
            reason: 'Cannot approve charges for cancelled shipments'
        };
    }

    // Check if already approved
    if (shipmentData.chargeStatus?.status === 'approved') {
        return {
            allowed: false,
            reason: 'Charges are already approved'
        };
    }

    // Check for high-severity exceptions
    if (!overrideExceptions && shipmentData.exceptionStatus?.hasExceptions) {
        const highSeverityExceptions = shipmentData.exceptionStatus.exceptions?.filter(
            ex => ex.severity === 'HIGH'
        ) || [];
        
        if (highSeverityExceptions.length > 0) {
            return {
                allowed: false,
                reason: `Cannot approve due to ${highSeverityExceptions.length} high-severity exception(s). Override required.`
            };
        }
    }

    // Check for missing actual costs
    if (!shipmentData.actualRates || !shipmentData.actualRates.totalCharges) {
        return {
            allowed: false,
            reason: 'Cannot approve charges without actual cost data'
        };
    }

    return {
        allowed: true,
        reason: 'Validation passed'
    };
}

/**
 * Log approval event for audit trail
 */
async function logApprovalEvent(shipmentId, shipmentID, userEmail, overrideExceptions, approvalNotes) {
    try {
        await db.collection('chargeApprovalLog').add({
            shipmentId: shipmentId,
            shipmentID: shipmentID,
            approvedBy: userEmail,
            approvedAt: admin.firestore.FieldValue.serverTimestamp(),
            overrideExceptions: overrideExceptions,
            approvalNotes: approvalNotes,
            action: 'charge_approval'
        });
    } catch (error) {
        logger.warn('Failed to log approval event:', error);
    }
}

/**
 * Bulk reject charges (opposite of approve)
 */
const rejectCharges = onCall({
    cors: true,
    maxInstances: 10,
    timeoutSeconds: 60
}, async (request) => {
    try {
        const { 
            shipmentIds, 
            rejectionReason = 'Manual rejection',
            requiresReview = true
        } = request.data;
        
        const userId = request.auth?.uid;
        const userEmail = request.auth?.email;

        if (!userId) {
            throw new Error('Authentication required');
        }

        if (!shipmentIds || !Array.isArray(shipmentIds) || shipmentIds.length === 0) {
            throw new Error('Shipment IDs array is required');
        }

        logger.info('❌ Rejecting charges', {
            shipmentCount: shipmentIds.length,
            rejectionReason,
            userId
        });

        const results = [];

        for (const shipmentId of shipmentIds) {
            try {
                // Update charge status to rejected/pending_review
                const updateData = {
                    chargeStatus: {
                        status: requiresReview ? 'pending_review' : 'rejected',
                        rejectedBy: userEmail,
                        rejectedAt: admin.firestore.FieldValue.serverTimestamp(),
                        rejectedByUserId: userId,
                        rejectionReason: rejectionReason,
                        autoGenerated: false
                    },
                    
                    [`statusHistory.${Date.now()}`]: {
                        status: 'unknown',
                        timestamp: admin.firestore.FieldValue.serverTimestamp(),
                        note: `Charges rejected: ${rejectionReason}`,
                        updatedBy: userEmail,
                        type: 'charges_rejected'
                    }
                };

                await db.collection('shipments').doc(shipmentId).update(updateData);

                results.push({
                    success: true,
                    shipmentId: shipmentId,
                    newStatus: requiresReview ? 'pending_review' : 'rejected'
                });

            } catch (error) {
                logger.error(`Failed to reject shipment ${shipmentId}:`, error);
                results.push({
                    success: false,
                    shipmentId: shipmentId,
                    error: error.message
                });
            }
        }

        const successCount = results.filter(r => r.success).length;

        return {
            success: true,
            processedCount: shipmentIds.length,
            successCount: successCount,
            results: results,
            message: `Rejected ${successCount}/${shipmentIds.length} shipments`
        };

    } catch (error) {
        logger.error('❌ Bulk rejection error:', error);
        return {
            success: false,
            error: error.message
        };
    }
});

module.exports = { approveCharges, rejectCharges }; 